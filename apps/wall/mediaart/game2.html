<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Audio-Reactive Media Art (Built-in Tracks)</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/addons/p5.sound.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#1a131c;overflow:hidden;font-family:system-ui}
    .ui{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;background:#0008;color:#eee;padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px)}
    .ui button{padding:6px 10px;border:0;border-radius:8px;background:#2b2b2b;color:#fff;cursor:pointer}
    .pill{display:flex;gap:6px}
    .pill > label{background:#ffffff12;padding:4px 8px;border-radius:999px;display:flex;align-items:center;gap:6px}
    .pill input[type=checkbox]{accent-color:#6bb7ff}
  </style>
</head>
<body>
<div class="ui">
  <button id="start">Start</button>
  <div class="pill">
    <label><input type="checkbox" id="lead" checked>Lead</label>
    <label><input type="checkbox" id="drum" checked>Drum</label>
    <label><input type="checkbox" id="bass" checked>Bass</label>
    <label><input type="checkbox" id="others" checked>Others</label>
  </div>
</div>

<script>
/* Built-in tracks:
   같은 디렉토리에 아래 4개 파일을 두세요.
   - Music Sample_Lead.mp3
   - Music Sample_Drum.mp3
   - Music Sample_Bass.mp3
   - Music Sample_Others.mp3
*/

let blobs=[], stars=[];
let t=0;

// p5.sound objects
const tracks = {
  lead:  { file:'Music%20Sample_Lead.mp3',   snd:null, fft:null, amp:null, on:true },
  drum:  { file:'Music%20Sample_Drum.mp3',   snd:null, fft:null, amp:null, on:true },
  bass:  { file:'Music%20Sample_Bass.mp3',   snd:null, fft:null, amp:null, on:true },
  others:{ file:'Music%20Sample_Others.mp3', snd:null, fft:null, amp:null, on:true },
};

function preload(){
  for (const k in tracks){
    const tr = tracks[k];
    tr.snd = loadSound(tr.file, 
      ()=>console.log('loaded:', tr.file),
      (e)=>console.warn('load fail:', tr.file, e)
    );
  }
}

function setup(){
  createCanvas(window.innerWidth, window.innerHeight);
  colorMode(HSB,360,100,100,1);
  noStroke();

  const s = min(width,height);
  blobs = [
    makeBlob(0, width*0.18, height*0.75, s*0.58),
    makeBlob(1, width*0.75, height*0.30, s*0.50),
    makeBlob(2, width*0.48, height*0.55, s*0.45)
  ];
  stars = [
    makeStar(width*0.27, height*0.22, s*0.10, 'lead'),
    makeStar(width*0.55, height*0.48, s*0.13, 'drum'),
    makeStar(width*0.28, height*0.80, s*0.10, 'bass')
  ];

  // 트랙별 분석기
  for (const k in tracks){
    tracks[k].fft = new p5.FFT(0.8, 64);
    tracks[k].amp = new p5.Amplitude();
  }

  // UI
  document.getElementById('start').onclick = async ()=>{
    const ac = getAudioContext(); if (ac.state!=='running') await ac.resume();
    for (const k in tracks){
      const tr = tracks[k];
      if (tr.snd && !tr.snd.isPlaying()){
        tr.snd.loop();            // 항상 루프
        tr.snd.setVolume(tr.on?1:0);
        tr.fft.setInput(tr.snd);
        tr.amp.setInput(tr.snd);
      }
    }
  };
  ['lead','drum','bass','others'].forEach(id=>{
    const el = document.getElementById(id);
    el.onchange = ()=>{ tracks[id].on = el.checked; if (tracks[id].snd) tracks[id].snd.setVolume(el.checked?1:0); };
  });
}

function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }

function draw(){
  background(280,25,8);

  // 트랙별 에너지 취합
  let bassE=0, midE=0, trebE=0, levelSum=0, active=0;
  for (const k in tracks){
    const tr = tracks[k];
    if (!tr.snd) continue;
    const fft = tr.fft, amp = tr.amp;
    const bass = fft.getEnergy('bass');
    const mid  = fft.getEnergy('mid');
    const treb = fft.getEnergy('treble');
    const lvl  = amp.getLevel();
    bassE += bass; midE += mid; trebE += treb; levelSum += lvl; active++;
  }
  if (active>0){ bassE/=active; midE/=active; trebE/=active; levelSum/=active; }

  // 블롭은 전체 밴드 평균에 반응
  for (const b of blobs){
    const bassPush = map(bassE,0,255, 0, 0.9);
    const midTwist = map(midE, 0,255, 0, 0.006);
    const trebFlick= map(trebE,0,255, 0, 0.004);
    b.rot += midTwist;
    b.x += (noise(b.seed + t)*2 - 1) * (0.3 + trebFlick*6);
    b.y += (noise(b.seed + 10 + t)*2 - 1) * (0.3 + trebFlick*6);
    b.scale = 0.92 + 0.08*(levelSum*2) + 0.10*bassPush;
    drawBlob(b);
  }

  // 별은 매핑된 트랙의 에너지로 반응
  for (const st of stars){
    const tr = tracks[st.mapType];
    let lvl=0, treb=0;
    if (tr && tr.fft && tr.amp){
      lvl  = tr.amp.getLevel();
      treb = tr.fft.getEnergy('treble');
    }
    drawGlowStar(st, lvl, treb);
  }

  t += 0.004;
}

/* ---------- Visual primitives ---------- */
function makeBlob(seed,x,y,r){ return {seed,x,y,r,hueBase:random(0,360),rot:random(TWO_PI),scale:1}; }
function drawBlob(b){
  push(); translate(b.x,b.y); rotate(b.rot); noStroke();
  const layers=18;
  for (let i=0;i<layers;i++){
    const pct=1 - i/(layers-1);
    const rr=b.r*b.scale*(0.45 + pct*0.7);
    const hu=(b.hueBase + i*12)%360;
    const al=0.04 + 0.08*pct;
    fill(hu,70,95,al);
    ellipse(0,0, rr*1.35, rr);
  }
  pop();
}

function makeStar(x,y,size,mapType){ return {x,y,size,mapType,phase:random(TWO_PI)}; }
function drawGlowStar(st, level, treb){
  push(); translate(st.x,st.y);
  const sparkle = map(treb,0,255, 0, 0.18);
  const pulse = 0.06*sin(frameCount*0.02 + st.phase);
  const baseSize = st.size * (1 + pulse + level*0.5);

  blendMode(ADD);
  for (let r=1.9;r>=1.0;r-=0.12){
    const a = map(r,1.0,1.9, 0.14, 0.03) + sparkle*0.25;
    starShape(baseSize*r, a, true);
  }
  starShape(baseSize, 0.9, false);
  pop();
}
function starShape(size, alpha, thick){
  const steps = thick ? 28 : 8;
  for (let i=0;i<steps;i++){
    const pct=i/(steps-1);
    const w = size*(1 - pct*0.85);
    const a = alpha*(thick ? (0.03 + 0.9*(1-pct)) : (0.4 + 0.6*(1-pct)));
    const hu=(200 + 180*pct)%360;
    fill(hu,70,100,a); rectMode(CENTER); noStroke();
    rect(0,0, w*1.8, w*0.15, w*0.1);
    rect(0,0, w*0.15, w*1.8, w*0.1);
    push(); rotate(PI/4);
    rect(0,0, w*1.3, w*0.12, w*0.08);
    rect(0,0, w*0.12, w*1.3, w*0.08);
    pop();
  }
  if (!thick){ fill(40,20,100,0.9); ellipse(0,0, size*0.22, size*0.22); }
}
</script>
</body>
</html>
