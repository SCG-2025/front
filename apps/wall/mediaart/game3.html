<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Star Media Art – 6 Tracks</title>
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
  <!-- Tone.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #0b0d10;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    .hint {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      color: #c8d0ff;
      font: 600 12px/1.2 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      letter-spacing: .2px;
      opacity: .85;
      user-select: none;
      text-align: center;
      background: rgba(20, 24, 36, .5);
      padding: 8px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      border: 1px solid rgba(120, 150, 255, .15);
    }
  </style>
</head>

<body>
  <div class="hint">💡 첫 클릭으로 오디오 권한 활성화 · 별 클릭 = 해당 트랙 On/Off · 배경 클릭 = 전체 재생/일시정지</div>
  <script>
    // ====== 음원 파일 경로 (같은 폴더 기준) ======
    const TRACKS = [
      { name: "Sample 1", file: "Music Sample_1.mp3", color: "#ffd166" },
      { name: "Sample 2", file: "Music Sample_2.mp3", color: "#06d6a0" },
      { name: "Bass", file: "Music Sample_Bass.mp3", color: "#118ab2" },
      { name: "Drum", file: "Music Sample_Drum.mp3", color: "#ef476f" },
      { name: "Lead", file: "Music Sample_Lead.mp3", color: "#a78bfa" },
      { name: "Others", file: "Music Sample_Others.mp3", color: "#f4a261" }
    ];

    // ====== Tone.js 오디오 노드 구성 ======
    const players = [];
    const analysers = []; // per-track waveform analyser
    const gains = [];     // per-track gain for mute / mix
    let master = null;
    let audioReady = false;

    async function initAudio() {
      if (audioReady) return;

      await Tone.start(); // 사용자 제스처 이후에만 가능
      master = new Tone.Limiter(-1).toDestination();
      for (const t of TRACKS) {
        const p = new Tone.Player({ url: t.file, autostart: false, loop: true });
        const g = new Tone.Gain(1);
        const an = new Tone.Analyser("waveform", 256);
        p.chain(g, an, master); players.push(p); gains.push(g); analysers.push(an);
      }
      audioReady = true;
    }
    function playAll() {
      players.forEach(p => { if (!p.state || p.state !== "started") p.start(); });
    }
    function pauseAll() {
      players.forEach(p => { if (p.state === "started") p.stop(); });
    }

    // ====== p5.js 비주얼 ======
    let stars = [], bgNoiseT = 0, margin;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      pixelDensity(Math.min(2, window.devicePixelRatio || 1));
      noStroke();
      margin = min(width, height) * 0.09;
      buildStars();
    }
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      margin = min(width, height) * 0.09;
      buildStars();
    }

    // 5각 별 점 좌표 만들기 (점 구름)
    function makeStarPoints(cx, cy, outerR, innerR, vertexN = 5, cloudCount = 650) {
      // 5각 별 폴리곤 경로
      const pts = [];
      const step = TWO_PI / vertexN;
      const half = step / 2;
      for (let i = 0; i < vertexN; i++) {
        const ao = -HALF_PI + step * i, ai = ao + half;
        pts.push([cx + cos(ao) * outerR, cy + sin(ao) * outerR]);
        pts.push([cx + cos(ai) * innerR, cy + sin(ai) * innerR]);
      }
      const edges = [];
      for (let i = 0; i < pts.length; i++) {
        const a = pts[i], b = pts[(i + 1) % pts.length];
        edges.push({ a, b, len: dist(a[0], a[1], b[0], b[1]) });
      }
      const total = edges.reduce((s, e) => s + e.len, 0);
      const cloud = [];
      for (let i = 0; i < cloudCount; i++) {
        let r = random(total), acc = 0, e = edges[0];
        for (const ed of edges) { acc += ed.len; if (r <= acc) { e = ed; break; } }
        const t = random(), x0 = lerp(e.a[0], e.b[0], t), y0 = lerp(e.a[1], e.b[1], t);
        const v = createVector(cx - x0, cy - y0).setMag(random(0, outerR * 0.12));
        const x = x0 + v.x + randomGaussian() * 0.8, y = y0 + v.y + randomGaussian() * 0.8;
        cloud.push({ x, y });
      }
      return cloud;
    }
    function buildStars() {
      stars = [];
      // 초기 배치: 랜덤 산개
      for (let i = 0; i < TRACKS.length; i++) {
        const R = min(width, height) * 0.16;     // 별 크기 기반 반지름(시각용)
        const r = R * 0.45;
        const cx = random(margin, width - margin);
        const cy = random(margin, height - margin);
        stars.push({
          baseX: cx, baseY: cy, cx, cy, R, r,
          color: TRACKS[i].color, label: TRACKS[i].name,
          energy: 0, active: false,
          nx: random(1000), ny: random(1000), // noise seed
          speed: 0.08 + random(0.05),        // 움직임 속도
          amp: min(width, height) * 0.06,       // 움직임 범위
          points: []                          // 나중에 생성
        });
      }
      // 겹침 완화
      relaxPositions(stars);

      // 점 구름 생성 (base 위치 기준)
      stars.forEach(s => {
        s.points = makeStarPoints(s.baseX, s.baseY, s.R, s.r, 5, 720);
      });
    }

    // 겹침 완화용 간단 반발
    function relaxPositions(arr, iters = 40) {
      for (let k = 0; k < iters; k++) {
        for (let i = 0; i < arr.length; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            const a = arr[i], b = arr[j];
            const d = dist(a.x, a.y, b.x, b.y);
            const minD = (a.R + b.R) * 0.95;
            if (d < minD) {
              const dir = createVector(b.x - a.x, b.y - a.y).setMag((minD - d) * 0.5);
              b.x += dir.x; b.y += dir.y; a.x -= dir.x; a.y -= dir.y;
            }
          }
          // 화면 경계 유도
          arr[i].x = constrain(arr[i].x, margin, width - margin);
          arr[i].y = constrain(arr[i].y, margin, height - margin);
        }
      }
    }


    function drawBG() {
      bgNoiseT += 0.003;
      for (let y = 0; y < height; y += 2) {
        const t = y / height, col = lerpColor(color(8, 10, 16), color(24, 26, 40), t);
        stroke(col); line(0, y, width, y);
      }
      noStroke();
      const n = 900;
      for (let i = 0; i < n; i++) {
        const x = noise(i * 0.013, bgNoiseT) * width;
        const y = noise(i * 0.017, 1000 + bgNoiseT) * height;
        const a = 8 + noise(i * 0.02, 2000 + bgNoiseT) * 22, alp = 8 + noise(i * 0.021) * 22;
        fill(180, 200, 255, alp); circle(x, y, a * 0.08);
      }
    }

    function draw() {
      background(10);
      drawBG();

      // 위치 업데이트 (Perlin Noise)
      const t = frameCount / 60;
      stars.forEach(s => {
        const offX = map(noise(s.nx + t * s.speed), 0, 1, -s.amp, s.amp);
        const offY = map(noise(s.ny + t * s.speed), 0, 1, -s.amp, s.amp);
        s.cx = constrain(s.baseX + offX, margin, width - margin);
        s.cy = constrain(s.baseY + offY, margin, height - margin);
      });
      // 각 트랙의 에너지(파형 평균 절댓값) 계산
      if (audioReady) {
        stars.forEach((s, idx) => {
          const arr = analysers[idx].getValue(); // Float32Array -1..1
          let sum = 0;
          for (let i = 0; i < arr.length; i++) sum += Math.abs(arr[i]);
          s.energy = sum / arr.length; // 0..1 정도 범위
          s.active = players[idx].state === "started";
        });
      }

      // 별 그리기
      stars.forEach(s => {
        const baseCol = color(s.color);
        const bright = constrain(map(s.energy, 0, 0.25, 0.15, 1.0), 0.15, 1.0);
        const sizePulse = 1 + (s.energy * 0.35);

        // Glow 셋업
        drawingContext.save();
        drawingContext.shadowBlur = 30 + s.energy * 120;
        drawingContext.shadowColor = color(red(baseCol), green(baseCol), blue(baseCol), 200);
        blendMode(ADD);

        // 점 구름
        for (let i = 0; i < s.points.length; i++) {
          const p = s.points[i];
          // 점들도 중심 이동을 따라가도록 동일 오프셋 적용
          const px = p.x + (s.cx - s.baseX);
          const py = p.y + (s.cy - s.baseY);
          const jitter = (noise(i * 0.013, frameCount * 0.01) - 0.5) * (1.5 + s.energy * 6);
          const d = (1.2 + noise(i * 0.02) * 1.6) * sizePulse;
          const col = color(red(baseCol), green(baseCol), blue(baseCol), 40 + bright * 160);
          fill(col); circle(px + jitter, py + jitter, d);
        }
        drawingContext.restore(); blendMode(BLEND);

        fill(220, 230, 255, 180); textAlign(CENTER, TOP); textSize(13);
        text(s.label + (s.active ? " ●" : " ○"), s.cx, s.cy + s.R * 0.9);
      });
    }    // 별 클릭 판정
    function mousePressed() {
      if (!audioReady) { initAudio(); return; }
      let hit = false;
      for (let i = 0; i < stars.length; i++) {
        const s = stars[i];
        if (dist(mouseX, mouseY, s.cx, s.cy) <= s.R * 1.05) {
          hit = true;
          if (players[i].state === "started") players[i].stop(); else players[i].start();
          break;
        }
      }
      if (!hit) {
        const anyPlaying = players.some(p => p.state === "started");
        if (anyPlaying) pauseAll(); else playAll();
      }
    }    // 모바일 터치 대응
    function touchStarted() {
      mousePressed();
      return false;
    }
  </script>
</body>

</html>