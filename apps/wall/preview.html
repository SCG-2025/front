<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PC 아바타 월드 - 크기 미리보기</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
  <styl        // 드래그 관련 애니메이션 업데이트
        if (avatar.isClicked) {
          avatar.clickTimer++;
          
          // 클릭 후 6프레임(약 0.1초) 후에 들어올리기 시작
          if (avatar.clickTimer > 6 && avatar.isDragged) {
            // 드래그 중일 때 빠르게 들어올리기 효과 (속도 증가)
            if (avatar.dragElevation < 12) {
              avatar.dragElevation += 4; // 2 → 4로 속도 증가
            }
          }
        } else {{
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      display: block;
      border: 2px solid #fff;
    }

    /* 팝업 스타일 */
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      display: none;
    }

    .popup-content {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 20px;
      border-radius: 15px 15px 0 0;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
      max-height: 300px;
      overflow-y: auto;
    }

    .popup-close {
      position: absolute;
      top: 10px;
      right: 15px;
      background: #ddd;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .popup-close:hover {
      background: #ccc;
    }

    .avatar-info {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }

    .avatar-image {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .avatar-details h3 {
      margin: 0 0 10px 0;
      color: #333;
    }

    .nickname-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .nickname-text {
      font-weight: bold;
      color: #333;
    }

    .keywords-container {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .keyword-tag {
      background: #f0f0f0;
      color: #666;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    .avatar-details p {
      margin: 5px 0;
      color: #666;
      line-height: 1.4;
    }

    .help-text {
      margin-top: 15px;
      font-size: 12px;
      color: #999;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
  </style>
</head>

<body>
  <!-- 팝업 오버레이 -->
  <div id="popupOverlay" class="popup-overlay">
    <div class="popup-content">
      <button class="popup-close" onclick="closePopup()">×</button>
      <div class="avatar-info">
        <img id="popupAvatarImage" class="avatar-image" src="avatar_sample.jpeg" alt="아바타">
        <div class="avatar-details">
          <h3>아바타 정보</h3>
          <div class="nickname-row">
            <span class="nickname-text"><span id="popupNickname">-</span></span>
            <div class="keywords-container" id="popupKeywords">
              <!-- 키워드 태그들이 여기에 동적으로 추가됩니다 -->
            </div>
          </div>
          <p><strong>카테고리:</strong> <span id="popupCategory">-</span></p>
          <p><strong>추억:</strong> <span id="popupMemory">-</span></p>
        </div>
      </div>
      <div class="help-text">
        이 아바타를 드래그해서 원하는 위치로 이동시킬 수 있습니다.<br>
        팝업 외부를 클릭하거나 × 버튼을 눌러 닫을 수 있습니다.
      </div>
    </div>
  </div>

  <script>
    let avatarImage;
    let testAvatars = [];
    let selectedAvatar = null;
    let selectedStageAvatar = null; // 무대 아바타 선택용
    let isDragging = false;
    let showPopup = false;
    let popupAvatar = null;
    let dragOffset = { x: 0, y: 0 };

    // 무대 슬롯 관리 (6개 슬롯: 0, 1, 2, 3, 4, 5)
    let stageSlots = [null, null, null, null, null, null];

    function preload() {
      avatarImage = loadImage('avatar_sample.jpeg');
    }

    function setup() {
      createCanvas(2560, 1760); // 아이맥 가로 화면에 맞춰 확장 (1920 → 2560)
      
      // 테스트용 움직이는 아바타들 생성 (5개)
      for (let i = 0; i < 5; i++) {
        testAvatars.push({
          id: 'avatar_' + i, // 고유 ID 추가
          x: random(200, 2360), // 새로운 가로 크기에 맞춤
          y: random(900, 1500),
          vx: random(-1, 1),
          vy: random(-1, 1),
          direction: random() > 0.5 ? 1 : -1,
          walkTimer: random(60, 240),
          idleTimer: 0,
          currentAction: 'walking',
          // 드래그 관련 속성 추가
          isDragged: false,
          dragElevation: 0,
          dropBounce: 0,
          dropBounceVel: 0,
          baseY: 0,
          clickTimer: 0,
          isClicked: false,
          // 무대 관련 속성 추가
          isOnStage: false,
          stageSlot: -1,
          isSpecial: (`삐삐${i + 1}`.includes('삐삐1') || `삐삐${i + 1}`.includes('삐삐2') || `삐삐${i + 1}`.includes('삐삐3') || `삐삐${i + 1}`.includes('삐삐4')), // 삐삐1~4만 특수 아바타
          // 임시 데이터 추가
          nickname: '삐삐' + (i + 1), // 각각 다른 닉네임
          category: ['사진', '음악', '영화', '음식', '여행'][i], // 다양한 카테고리
          memory: '초등학생 때 부모님과 함께 함덕해수욕장에 간 기억이 있어요',
          keywords: [
            ['가족', '해변', '추억'],
            ['음악', '콘서트', '감동'],
            ['영화관', '데이트', '로맨스'],
            ['맛집', '친구', '만족'],
            ['여행', '모험', '힐링']
          ][i]
        });
      }
      
      drawMainScreen();
    }

    // 무대 슬롯 위치 계산
    function getStageSlotPosition(slotIndex) {
      const stageW = 2560 / 3;
      const stageX = (2560 - stageW) / 2;
      const stageY = 640;
      const spacing = stageW / 7; // 6개 슬롯이므로 7등분
      
      return {
        x: stageX + spacing * (slotIndex + 1),
        y: stageY
      };
    }

    // 가장 가까운 빈 무대 슬롯 찾기
    function findNearestEmptyStageSlot(x, y) {
      let nearestSlot = -1;
      let minDistance = Infinity;
      
      for (let i = 0; i < 6; i++) {
        if (stageSlots[i] === null) { // 빈 슬롯인 경우
          const slotPos = getStageSlotPosition(i);
          const distance = dist(x, y, slotPos.x, slotPos.y);
          if (distance < minDistance) {
            minDistance = distance;
            nearestSlot = i;
          }
        }
      }
      
      return nearestSlot;
    }

    // 무대 영역에 있는지 확인
    function isInStageArea(x, y) {
      const stageLeft = 853;
      const stageRight = 1707;
      const stageTop = 480;
      const stageBottom = 800;
      
      return x >= stageLeft && x <= stageRight && y >= stageTop && y <= stageBottom;
    }

    function draw() {
      drawMainScreen();
      
      // 테스트 아바타들 애니메이션
      testAvatars.forEach(avatar => {
        // 무대 위 아바타는 움직이지 않음
        if (avatar.isOnStage) {
          // 무대 위에서는 정적으로 유지
          return;
        }
        
        // 멈춘 상태면 움직이지 않음
        if (avatar.currentAction === 'stopped') {
          // 아무것도 하지 않음
        }
        else if (avatar.currentAction === 'idle') {
          avatar.idleTimer--;
          if (avatar.idleTimer <= 0) {
            const directions = [
              {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}
            ];
            const dir = random(directions);
            avatar.vx = dir.dx * random(0.5, 1.5);
            avatar.vy = dir.dy * random(0.5, 1.5);
            avatar.direction = avatar.vx > 0 ? 1 : (avatar.vx < 0 ? -1 : avatar.direction);
            avatar.currentAction = 'walking';
            avatar.walkTimer = random(60, 240);
          }
        } else if (avatar.currentAction === 'walking') {
          avatar.walkTimer--;
          avatar.x += avatar.vx;
          avatar.y += avatar.vy;
          
          if (avatar.walkTimer <= 0) {
            avatar.vx = 0;
            avatar.vy = 0;
            avatar.currentAction = 'idle';
            avatar.idleTimer = random(30, 120);
          }
          
          // 경계 충돌 처리 (걷는 중일 때만)
          if (avatar.x < 0 || avatar.x > 2560) {
            avatar.vx *= -1;
            avatar.direction *= -1;
            avatar.x = constrain(avatar.x, 0, 2560);
          }
          if (avatar.y < 480 || avatar.y > 1760) {
            avatar.vy *= -1;
            avatar.y = constrain(avatar.y, 480, 1760);
          }
          
          // 무대 충돌 처리
          const stageLeft = 853, stageRight = 1707, stageTop = 480, stageBottom = 800;
          if (avatar.y >= stageTop && avatar.y <= stageBottom && 
              avatar.x >= stageLeft && avatar.x <= stageRight) {
            const centerX = (stageLeft + stageRight) / 2;
            const centerY = (stageTop + stageBottom) / 2;
            const dx = avatar.x - centerX;
            const dy = avatar.y - centerY;
            
            if (Math.abs(dx) > Math.abs(dy)) {
              avatar.vx *= -1;
              avatar.direction *= -1;
              avatar.x = dx > 0 ? stageRight + 5 : stageLeft - 5;
            } else {
              avatar.vy *= -1;
              avatar.y = dy > 0 ? stageBottom + 5 : stageTop - 5;
            }
          }
        }

        // 드래그 관련 애니메이션 업데이트
        if (avatar.isClicked) {
          avatar.clickTimer++;
          
          // 클릭 후 10프레임(약 0.17초) 후에 들어올리기 시작
          if (avatar.clickTimer > 10 && avatar.isDragged) {
            // 드래그 중일 때 빠르게 들어올리기 효과 (속도 증가)
            if (avatar.dragElevation < 12) {
              avatar.dragElevation += 4; // 2 → 4로 속도 증가
            }
          }
        } else {
          // 클릭 해제 시 바운스 효과
          if (avatar.dropBounce !== 0) {
            avatar.dropBounce += avatar.dropBounceVel;
            avatar.dropBounceVel += 1.2; // 중력 강화 (0.8 → 1.2)
            if (avatar.dropBounce >= 0) {
              avatar.dropBounce = 0;
              avatar.dropBounceVel *= -0.4; // 바운스 감쇠 강화 (-0.6 → -0.4)
              if (Math.abs(avatar.dropBounceVel) < 0.5) { // 종료 조건 강화
                avatar.dropBounceVel = 0;
              }
            }
          }
          // 들어올린 효과 빠르게 원상복구
          if (avatar.dragElevation > 0) {
            avatar.dragElevation -= 3; // 속도 증가 (1 → 3)
            if (avatar.dragElevation < 0) avatar.dragElevation = 0;
          }
        }

        // 현재 Y 위치 계산 (들어올림 + 바운스 효과 적용)
        const currentY = avatar.y - avatar.dragElevation + avatar.dropBounce;

        // 드래그 중일 때 그림자 그리기 (딜레이 후에만 표시)
        if (avatar.isClicked && avatar.clickTimer > 6 && avatar.dragElevation > 0) {
          push();
          fill(0, 0, 0, 50); // 반투명 검은색 그림자
          noStroke();
          ellipse(avatar.x, avatar.y + 32, 50 - avatar.dragElevation, 15 - avatar.dragElevation/3); // 그림자 크기 조정
          pop();
        }

        // 아바타 그리기
        push();
        translate(avatar.x, currentY);
        if (avatar.direction === -1) {
          scale(-1, 1);
        }
        imageMode(CENTER);
        
        // 선택된 아바타는 더 크게 표시하고 하이라이트 효과 추가 (팝업이 열렸을 때만)
        if (showPopup && popupAvatar && popupAvatar.id === avatar.id) {
          // 배경 원 (하이라이트 효과)
          fill(255, 215, 0, 150); // 골드 색상, 반투명
          ellipse(0, 0, 90, 90);
          // 선택된 아바타는 1.25배 크기
          image(avatarImage, 0, 0, 80, 80);
        } else {
          // 일반 아바타
          image(avatarImage, 0, 0, 64, 64);
        }
        pop();

        // 닉네임 표시 (아바타 위에)
        push();
        // 텍스트 설정
        textAlign(CENTER, BOTTOM);
        textSize(12);
        fill(255); // 흰색 텍스트
        stroke(0); // 검은색 외곽선
        strokeWeight(3);
        
        // 닉네임 표시 (아바타 위쪽 5px, 드래그/바운스 효과 적용)
        text(avatar.nickname || '사용자', avatar.x, currentY - 37);
        
        // 외곽선 없는 텍스트 한번 더 그리기 (깔끔한 표시를 위해)
        noStroke();
        fill(255);
        text(avatar.nickname || '사용자', avatar.x, currentY - 37);
        pop();
      });
      
      // HTML 팝업을 사용하므로 p5.js 팝업 그리기는 제거
    }

    function drawMainScreen() {
      background('#222');
      
      // 스크린 공간 (회색, 2560x480)
      fill('#cccccc');
      rect(0, 0, 2560, 480);

      // 무대 공간 (갈색, 가운데 1/3 = 853px)
      const stageW = 2560 / 3; // 853.33
      const stageX = (2560 - stageW) / 2;
      fill('#a67c52');
      rect(stageX, 480, stageW, 320);

      // 자유 공간 (하늘색)
      fill('#7ecbff');
      noStroke();
      rect(0, 800, 2560, 960); // 무대 아래 전체
      rect(0, 480, stageX, 320); // 왼쪽
      rect(stageX + stageW, 480, stageX, 320); // 오른쪽

      // 스크린 3분할 표시선
      stroke('#888');
      strokeWeight(2);
      for (let i = 1; i < 3; i++) {
        line((2560 / 3) * i, 0, (2560 / 3) * i, 480);
      }
      noStroke();

      // 빈 무대 슬롯 표시 (6개)
      const spacing = stageW / 7;
      for (let i = 0; i < 6; i++) {
        if (stageSlots[i] === null) { // 빈 슬롯인 경우에만
          const slotPos = getStageSlotPosition(i);
          push();
          fill(255, 255, 255, 30); // 매우 연한 흰색 원
          noStroke();
          ellipse(slotPos.x, slotPos.y, 70, 70); // 슬롯 위치 표시
          pop();
          
          // 슬롯 번호 표시
          push();
          textAlign(CENTER, CENTER);
          textSize(10);
          fill(255, 255, 255, 100);
          text(`SLOT ${i + 1}`, slotPos.x, slotPos.y);
          pop();
        }
      }

      // 화면 정보 표시
      fill(255);
      textSize(16);
      textAlign(LEFT);
      text('Canvas Size: 2560 x 1760 (iMac 적합)', 20, 30);
      text('Avatar Size: 64 x 64 pixels', 20, 50);
      text('Stage Avatars: 6 (fixed)', 20, 70);
      text('Moving Avatars: ' + testAvatars.length + ' (animated)', 20, 90);
    }

    // 마우스 이벤트 처리
    function mousePressed() {
      // 팝업이 열려있을 때는 캔버스 클릭 무시
      if (showPopup) {
        return;
      }

      // 아바타 클릭 감지
      for (let avatar of testAvatars) {
        let distance = dist(mouseX, mouseY, avatar.x, avatar.y);
        if (distance <= 32) { // 64x64 아바타의 절반
          selectedAvatar = avatar;
          selectedStageAvatar = null; // 무대 아바타 선택 해제
          isDragging = false;
          dragOffset.x = mouseX - avatar.x;
          dragOffset.y = mouseY - avatar.y;
          
          // 아바타 멈추기 및 클릭 상태 초기화
          avatar.currentAction = 'stopped';
          avatar.vx = 0;
          avatar.vy = 0;
          avatar.isClicked = true;
          avatar.clickTimer = 0;
          avatar.isDragged = false; // 아직 드래그가 아님
          avatar.baseY = avatar.y; // 원래 위치 저장
          return;
        }
      }

      // 무대 아바타 클릭 감지 (고정 아바타)
      const stageW = 2560 / 3;
      const stageX = (2560 - stageW) / 2;
      const stageY = 640;
      const spacing = stageW / 7;
      
      for (let i = 0; i < 6; i++) {
        const x = stageX + spacing * (i + 1);
        let distance = dist(mouseX, mouseY, x, stageY);
        if (distance <= 32) { // 64x64 아바타의 절반
          // 무대 아바타 정보 생성 후 팝업 표시
          const stageAvatarInfo = {
            id: 'stage_' + i,
            isStageAvatar: true,
            stageIndex: i,
            nickname: '무대 아바타 ' + (i + 1),
            category: '공연',
            memory: '무대 위에서 멋진 공연을 준비하고 있습니다.',
            keywords: ['공연', '무대', '예술']
          };
          showPopupFor(stageAvatarInfo);
          selectedAvatar = null; // 동적 아바타 선택 해제
          selectedStageAvatar = null;
          return;
        }
      }
      
      // 기존 아바타 추가 기능 (자유공간 클릭 시)
      if (mouseX > 0 && mouseX < 2560 && mouseY > 800 && mouseY < 1760) {
        testAvatars.push({
          id: 'avatar_' + Date.now(), // 타임스탬프로 고유 ID 생성
          x: mouseX,
          y: mouseY,
          vx: random(-1, 1),
          vy: random(-1, 1),
          direction: random() > 0.5 ? 1 : -1,
          walkTimer: random(60, 240),
          idleTimer: 0,
          currentAction: 'walking',
          // 드래그 관련 속성 추가
          isDragged: false,
          dragElevation: 0,
          dropBounce: 0,
          dropBounceVel: 0,
          baseY: mouseY,
          clickTimer: 0,
          isClicked: false,
          nickname: '삐삐' + testAvatars.length,
          category: '일반',
          memory: '초등학생 때 부모님과 함께 함덕해수욕장에 간 기억이 있어요',
          keywords: ['해변', '가족', '추억']
        });
      }
    }

    function mouseDragged() {
      if (selectedAvatar) {
        isDragging = true;
        selectedAvatar.isDragged = true; // 실제 드래그 시작
        selectedAvatar.x = mouseX - dragOffset.x;
        selectedAvatar.y = mouseY - dragOffset.y;
        
        // 경계 제한
        selectedAvatar.x = constrain(selectedAvatar.x, 0, 2560);
        selectedAvatar.y = constrain(selectedAvatar.y, 480, 1760);
        
        // 무대 영역 제한
        const stageLeft = 853, stageRight = 1707, stageTop = 480, stageBottom = 800;
        if (selectedAvatar.y >= stageTop && selectedAvatar.y <= stageBottom && 
            selectedAvatar.x >= stageLeft && selectedAvatar.x <= stageRight) {
          // 무대 밖으로 밀어내기
          const centerX = (stageLeft + stageRight) / 2;
          if (selectedAvatar.x < centerX) {
            selectedAvatar.x = stageLeft - 32;
          } else {
            selectedAvatar.x = stageRight + 32;
          }
        }
      }
    }

    function mouseReleased() {
      if (selectedAvatar) {
        if (!isDragging) {
          // 드래그하지 않고 클릭만 했으면 팝업 표시
          selectedAvatar.isClicked = false; // 클릭 상태 해제
          selectedAvatar.isDragged = false;
          showPopupFor(selectedAvatar);
        } else {
          // 드래그 완료 처리
          selectedAvatar.isClicked = false;
          selectedAvatar.isDragged = false;
          
          // 특수 아바타이고 무대 영역에 드롭한 경우
          if (selectedAvatar.isSpecial && isInStageArea(selectedAvatar.x, selectedAvatar.y)) {
            // 가장 가까운 빈 슬롯 찾기
            const nearestSlot = findNearestEmptyStageSlot(selectedAvatar.x, selectedAvatar.y);
            
            if (nearestSlot !== -1) {
              // 기존 슬롯에서 제거
              if (selectedAvatar.isOnStage && selectedAvatar.stageSlot !== -1) {
                stageSlots[selectedAvatar.stageSlot] = null;
              }
              
              // 새 슬롯에 배치
              const slotPos = getStageSlotPosition(nearestSlot);
              selectedAvatar.x = slotPos.x;
              selectedAvatar.y = slotPos.y;
              selectedAvatar.isOnStage = true;
              selectedAvatar.stageSlot = nearestSlot;
              stageSlots[nearestSlot] = selectedAvatar.id;
              
              // 무대 위에서는 움직이지 않도록
              selectedAvatar.currentAction = 'stopped';
            } else {
              // 빈 슬롯이 없으면 무대 밖으로
              selectedAvatar.y = 850; // 무대 아래로
              selectedAvatar.isOnStage = false;
              if (selectedAvatar.stageSlot !== -1) {
                stageSlots[selectedAvatar.stageSlot] = null;
                selectedAvatar.stageSlot = -1;
              }
              selectedAvatar.currentAction = 'idle';
              selectedAvatar.idleTimer = random(30, 120);
            }
          } else {
            // 무대 밖으로 드래그한 경우
            if (selectedAvatar.isOnStage && selectedAvatar.stageSlot !== -1) {
              stageSlots[selectedAvatar.stageSlot] = null;
              selectedAvatar.isOnStage = false;
              selectedAvatar.stageSlot = -1;
            }
            
            // 바운스 효과와 함께 일반 모드로
            selectedAvatar.dropBounce = -6;
            selectedAvatar.dropBounceVel = -1.5;
            selectedAvatar.baseY = selectedAvatar.y;
            selectedAvatar.currentAction = 'idle';
            selectedAvatar.idleTimer = random(30, 120);
          }
        }
        selectedAvatar = null;
        isDragging = false;
      }
    }

    function showPopupFor(avatar) {
      popupAvatar = avatar;
      showPopup = true;
      
      // HTML 팝업에 정보 채우기
      document.getElementById('popupNickname').textContent = avatar.nickname;
      document.getElementById('popupCategory').textContent = avatar.category;
      document.getElementById('popupMemory').textContent = avatar.memory;
      
      // 키워드 태그들 생성
      const keywordsContainer = document.getElementById('popupKeywords');
      keywordsContainer.innerHTML = ''; // 기존 키워드 제거
      
      if (avatar.keywords && Array.isArray(avatar.keywords)) {
        avatar.keywords.forEach(keyword => {
          const keywordTag = document.createElement('span');
          keywordTag.className = 'keyword-tag';
          keywordTag.textContent = '#' + keyword;
          keywordsContainer.appendChild(keywordTag);
        });
      }
      
      // 팝업 표시
      document.getElementById('popupOverlay').style.display = 'block';
      
      // 동적 아바타만 멈춤 상태로 만듦 (무대 아바타는 고정이므로 제외)
      if (!avatar.isStageAvatar) {
        avatar.currentAction = 'stopped';
      }
    }

    function closePopup() {
      showPopup = false;
      
      // HTML 팝업 숨기기
      document.getElementById('popupOverlay').style.display = 'none';
      
      if (popupAvatar) {
        // 동적 아바타만 다시 움직이게 함 (무대 아바타는 고정이므로 제외)
        if (!popupAvatar.isStageAvatar) {
          popupAvatar.currentAction = 'idle';
          popupAvatar.idleTimer = random(30, 120);
        }
        popupAvatar = null;
      }
    }

    // 팝업 오버레이 클릭 시 닫기
    document.getElementById('popupOverlay').addEventListener('click', function(e) {
      if (e.target === this) {
        closePopup();
      }
    });
  </script>
</body>

</html>
