<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Media Art — Beat Snap</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/addons/p5.sound.min.js"></script>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #0f0f13;
      overflow: hidden
    }

    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges
    }

    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      background: #0008;
      color: #eee;
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      font: 12px system-ui
    }

    .ui label {
      background: #ffffff12;
      padding: 4px 8px;
      border-radius: 999px;
      display: flex;
      gap: 6px;
      align-items: center
    }

    .ui input[type=range] {
      width: 120px
    }

    .pill {
      display: flex;
      gap: 6px
    }
  </style>
</head>

<body>
  <div class="ui">
    <button id="start">Start</button>
    <div class="pill">
      <label><input type="checkbox" id="lead" checked>Lead</label>
      <label><input type="checkbox" id="drum" checked>Drum</label>
      <label><input type="checkbox" id="bass" checked>Bass</label>
      <label><input type="checkbox" id="others" checked>Others</label>
    </div>
    <label>sens <input id="sens" type="range" min="0.6" max="2.0" step="0.05" value="1.15"></label>
    <label>grid <input id="grid" type="range" min="6" max="30" step="1" value="14"></label>
    <span id="bpm" style="opacity:.85"></span>
  </div>

  <script>
    /* ====== Tracks ====== */
    const tracks = {
      lead: { file: 'Music%20Sample_Lead.mp3', snd: null, fft: null, amp: null, on: true },
      drum: { file: 'Music%20Sample_Drum.mp3', snd: null, fft: null, amp: null, on: true },
      bass: { file: 'Music%20Sample_Bass.mp3', snd: null, fft: null, amp: null, on: true },
      others: { file: 'Music%20Sample_Others.mp3', snd: null, fft: null, amp: null, on: true },
    };
    function preload() {
      for (const k in tracks) {
        const tr = tracks[k];
        tr.snd = loadSound(tr.file, () => console.log('loaded', tr.file), e => console.warn('fail', tr.file, e));
      }
    }

    /* ====== Low-res pixel canvas ====== */
    let pg, gridW = 192, gridH = 128, scaleX = 1, scaleY = 1;
    function setupOffscreen() {
      gridH = Math.round(gridW * (height / width));
      pg = createGraphics(gridW, gridH);
      pg.noSmooth();
      pg.colorMode(HSB, 360, 100, 100, 1);
      scaleX = width / gridW; scaleY = height / gridH;
    }

    /* ====== Beat detector (drum bass band) ====== */
    class BeatSnap {
      constructor() {
        this.prevSpec = new Array(32).fill(0);
        this.threshold = 0.0;
        this.gain = 0.9;           // adaptive threshold EMA
        this.lastHit = 0;
        this.minGap = 0.12;        // seconds (debounce)
        this.ivalEMA = null;       // avg inter-beat interval
        this.lastTime = null;
        this.flash = 0;            // for strobe
        this.subDivPhase = 0;      // 0..1
      }
      update(drFFt) {
        // spectral flux (bass bins only)
        const spec = drFFt.analyze(64); // 64 bins
        const N = 12;                   // use first ~12 bins ≈ low/bass
        let flux = 0;
        for (let i = 0; i < N; i++) {
          const v = spec[i] / 255;
          const d = Math.max(0, v - this.prevSpec[i] / 255);
          flux += d;
          this.prevSpec[i] = spec[i];
        }
        // adaptive threshold
        this.threshold = this.threshold * this.gain + flux * (1 - this.gain);

        const now = millis() / 1000;
        const sens = parseFloat(document.getElementById('sens').value);
        const passed = (flux > this.threshold * sens) && (now - this.lastHit > this.minGap);

        let hit = false;
        if (passed) {
          hit = true;
          this.flash = 1;
          if (this.lastTime) {
            const ival = now - this.lastTime;
            this.ivalEMA = this.ivalEMA == null ? ival : lerp(this.ivalEMA, ival, 0.2);
          }
          this.lastTime = now;
          this.lastHit = now;
        }
        // decay flash
        this.flash = lerp(this.flash, 0, 0.25);

        // sub-step clock from EMA (1/4 notes)
        if (this.ivalEMA) {
          const beat = this.ivalEMA;
          const q = (now - (this.lastTime || now)) / beat;
          this.subDivPhase = (q * 4) % 1; // quarter notes phase 0..1
        }
        return hit;
      }
      bpm() {
        return this.ivalEMA ? (60 / this.ivalEMA) : 0;
      }
    }
    let snap;

    /* ====== Visual State (snappy) ====== */
    let blobs, stars, palette, paletteStep = 0, flashAlpha = 0;
    const gradHex = ['#ff6b88', '#ffb35a', '#d9ff63', '#6de1ff', '#a88bff']; // 핫→쿨 오색 (무지개X)
    function hexCol(h) { const v = h.replace('#', ''); return color(parseInt(v.slice(0, 2), 16), parseInt(v.slice(2, 4), 16), parseInt(v.slice(4, 6), 16)); }
    function sampleGradIdx(i) { // hard step palette
      const a = constrain(i, 0, gradHex.length - 1) | 0;
      const c = hexCol(gradHex[a]);
      pg.fill(hue(c), saturation(c), brightness(c), 1);
      return c;
    }

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);
      noSmooth();
      setupOffscreen();
      snap = new BeatSnap();

      // analyzers
      for (const k in tracks) { tracks[k].fft = new p5.FFT(0.8, 64); tracks[k].amp = new p5.Amplitude(); }

      // visual objects
      const s = min(gridW, gridH);
      blobs = [
        { x: 0.22 * gridW, y: 0.72 * gridH, r: 0.42 * s, hue: 320, tx: 0, ty: 0, scale: 1 },
        { x: 0.72 * gridW, y: 0.30 * gridH, r: 0.34 * s, hue: 25, tx: 0, ty: 0, scale: 1 },
        { x: 0.48 * gridW, y: 0.55 * gridH, r: 0.31 * s, hue: 200, tx: 0, ty: 0, scale: 1 },
      ];
      stars = [
        { x: 0.26 * gridW, y: 0.20 * gridH, size: 0.12 * s, map: 'lead', rot: 0, thick: 3 },
        { x: 0.55 * gridW, y: 0.48 * gridH, size: 0.14 * s, map: 'drum', rot: 0, thick: 3 },
        { x: 0.28 * gridW, y: 0.80 * gridH, size: 0.11 * s, map: 'bass', rot: 0, thick: 3 },
      ];
      palette = gradHex.map(hexCol);

      // UI
      document.getElementById('start').onclick = async () => {
        const ac = getAudioContext(); if (ac.state !== 'running') await ac.resume();
        for (const k in tracks) {
          const tr = tracks[k];
          if (tr.snd && !tr.snd.isPlaying()) {
            tr.snd.loop(); tr.snd.setVolume(tr.on ? 1 : 0);
            tr.fft.setInput(tr.snd); tr.amp.setInput(tr.snd);
          }
        }
      };
      ['lead', 'drum', 'bass', 'others'].forEach(id => {
        const el = document.getElementById(id);
        el.onchange = () => { tracks[id].on = el.checked; if (tracks[id].snd) tracks[id].snd.setVolume(el.checked ? 1 : 0); };
      });
    }

    function windowResized() { resizeCanvas(window.innerWidth, window.innerHeight); setupOffscreen(); }

    /* ====== Draw ====== */
    function draw() {
      // energies
      const E = {};
      for (const id in tracks) {
        const tr = tracks[id];
        E[id] = tr.snd ? { bass: tr.fft.getEnergy('bass'), mid: tr.fft.getEnergy('mid'), treb: tr.fft.getEnergy('treble'), lvl: tr.amp.getLevel() }
          : { bass: 0, mid: 0, treb: 0, lvl: 0 };
      }

      // beat update from DRUM
      const hit = snap.update(tracks.drum.fft);
      const bpmEl = document.getElementById('bpm'); bpmEl.textContent = snap.bpm() ? `BPM ${snap.bpm().toFixed(0)}` : 'BPM --';

      // on beat: hard snap targets
      if (hit) {
        paletteStep = (paletteStep + 1) % palette.length;
        flashAlpha = 1;

        // blobs pick new snapped target on grid
        const gs = parseInt(document.getElementById('grid').value, 10); // grid size (px on low-res)
        blobs.forEach((b, i) => {
          const gx = Math.round(random(0.18 * gridW, 0.82 * gridW) / gs) * gs;
          const gy = Math.round(random(0.22 * gridH, 0.85 * gridH) / gs) * gs;
          b.tx = gx; b.ty = gy;
          b.tscale = 0.92 + 0.35 * E.bass.lvl + 0.25 * E.drum.lvl; // size step
        });

        // stars toggle rotation/thickness
        stars.forEach((s, i) => {
          s.rot = (s.rot + PI / 4) % TWO_PI;
          s.thick = (s.thick === 3) ? 5 : 3;
        });
      }

      // between beats: decay flash and ease motion
      flashAlpha = lerp(flashAlpha, 0, 0.25);
      blobs.forEach(b => {
        b.x = (b.tx) ? lerp(b.x, b.tx, 0.45) : b.x;
        b.y = (b.ty) ? lerp(b.y, b.ty, 0.45) : b.y;
        b.scale = b.tscale ? lerp(b.scale || 1, b.tscale, 0.35) : (b.scale || 1);
      });

      // low-res render
      pg.background(280, 25, 10);

      // background strobe on beat & quarter-phase bars
      if (flashAlpha > 0.02) {
        pg.noStroke();
        pg.fill(0, 0, 100, 0.18 * flashAlpha);
        pg.rect(0, 0, gridW, gridH);
      }
      drawQuarterBars();

      // blobs (pixel discs)
      blobs.forEach((b, idx) => drawPixelBlob(b, sampleGradIdx(paletteStep)));

      // stars (snappy crosses)
      stars.forEach(s => {
        const tr = tracks[s.map];
        const lvl = tr.amp.getLevel(), treb = tr.fft.getEnergy('treble');
        drawPixelStar(s, lvl, treb);
      });

      // up-scale
      background(10);
      image(pg, 0, 0, width, height);


    }

    function drawQuarterBars() {
      if (!snap.ivalEMA) return;
      const phase = snap.subDivPhase; // 0..1 within a 1/4
      const bars = 4;
      const w = Math.ceil(gridW / bars);
      for (let i = 0; i < bars; i++) {
        const a = (i === 0) ? 0.08 + 0.12 * snap.flash : 0.05;
        pg.noStroke(); pg.fill(0, 0, 100, a * (i === 0 ? 1 : 0.6));
        pg.rect(i * w, 0, w, 2);                // top
        pg.rect(i * w, gridH - 2, w, 2);          // bottom
      }
    }

    /* === Pixel primitives === */
    function drawPixelBlob(b, col) {
      const rr = (b.r * 0.22) * b.scale;
      const step = 2;
      pg.noStroke();
      for (let y = -rr; y <= rr; y += step) {
        const span = Math.sqrt(rr * rr - y * y);
        for (let x = -span; x <= span; x += step) {
          const d = (Math.abs(x) + Math.abs(y)) / rr;
          const a = (1 - d) * 0.8;
          pg.fill(hue(col), saturation(col), brightness(col), a);
          pg.rect(Math.floor(b.x + x), Math.floor(b.y + y), step, step);
        }
      }
    }
    function drawPixelStar(s, lvl, treb) {
      const base = s.size * (1 + 0.6 * lvl);
      const size = Math.floor(base);
      const th = s.thick;
      const cx = Math.floor(s.x), cy = Math.floor(s.y);

      pg.push();
      pg.translate(cx, cy);
      pg.rotate(s.rot);

      // glow (blocky)
      for (let r = 3; r >= 1; r--) {
        const w = Math.floor(size * (1 + r * 0.35));
        const a = 0.10 + 0.06 * r + 0.002 * treb;
        pg.noStroke(); pg.fill(200 + r * 25, 70, 100, a);
        // horiz
        pg.rect(-w / 2, -th / 2, w, th);
        // vert
        pg.rect(-th / 2, -w / 2, th, w);
      }
      // core
      pg.noStroke(); pg.fill(40, 20, 100, 0.95);
      pg.rect(-size / 2, -th / 2, size, th);
      pg.rect(-th / 2, -size / 2, th, size);

      pg.pop();
    }

  </script>
</body>

</html>